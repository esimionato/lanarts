/*
 * functions.h:
 *  Provides ability to push a CPP function.
 */

#ifndef LUAWRAP_FUNCTIONS_H_
#define LUAWRAP_FUNCTIONS_H_

#include <typeinfo>
#include <lua.hpp>

#include <luawrap/config.h>
#include <luawrap/luawrap.h>

namespace luawrap {
	namespace _private {

		bool argcheck(lua_State* L, const char* funcname, int argn,
				bool arg_ok);

		template<typename T>
		struct FuncWrap {
			// Nothing, if it gets to the fallback it is not supported
		};

		/******************************************************************************
		 * START AUTOGENERATED CODE -- Here be DRAGONS. Use generate-functions.py     *
		 ******************************************************************************/

		template<>
		struct FuncWrap<void (*)()> {
			static int cppfunction(lua_State* L) {

				((void (*)())lua_touserdata(L, lua_upvalueindex(1)))();
				return 0;
			}
		};

		template<typename R>
		struct FuncWrap<R (*)()> {
			static int cppfunction(lua_State* L) {

				push<R>(L, ((R (*)())lua_touserdata(L, lua_upvalueindex(1)))());
				return 1;
			}
		};

		template<typename A1>
		struct FuncWrap<void (*)(A1)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))) {
					return 0;
				}
				((void (*)(A1))lua_touserdata(L, lua_upvalueindex(1)))(
						get<A1>(L, 1));
				return 0;
			}
		};

		template<typename R, typename A1>
		struct FuncWrap<R (*)(A1)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))) {
					return 0;
				}
				push<R>(L,
						((R (*)(A1))lua_touserdata(L, lua_upvalueindex(1)))(
								get<A1>(L, 1)));
				return 1;
			}
		};

		template<typename A1, typename A2>
		struct FuncWrap<void (*)(A1, A2)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))) {
					return 0;
				}
				((void (*)(A1, A2))lua_touserdata(L, lua_upvalueindex(1)))(
						get<A1>(L, 1), get<A2>(L, 2));
				return 0;
			}
		};

		template<typename R, typename A1, typename A2>
		struct FuncWrap<R (*)(A1, A2)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))) {
					return 0;
				}
				push<R>(L,
						((R (*)(A1, A2))lua_touserdata(L, lua_upvalueindex(1)))(
								get<A1>(L, 1), get<A2>(L, 2)));
				return 1;
			}
		};

		template<typename A1, typename A2, typename A3>
		struct FuncWrap<void (*)(A1, A2, A3)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3,
								check<A3>(L, 3))) {
					return 0;
				}
				((void (*)(A1, A2, A3))lua_touserdata(L, lua_upvalueindex(1)))(
						get<A1>(L, 1), get<A2>(L, 2), get<A3>(L, 3));
				return 0;
			}
		};

		template<typename R, typename A1, typename A2, typename A3>
		struct FuncWrap<R (*)(A1, A2, A3)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3,
								check<A3>(L, 3))) {
					return 0;
				}
				push<R>(L,
						((R (*)(A1, A2, A3))lua_touserdata(L,
								lua_upvalueindex(1)))(get<A1>(L, 1),
								get<A2>(L, 2), get<A3>(L, 3)));
				return 1;
			}
		};

		template<typename A1, typename A2, typename A3, typename A4>
		struct FuncWrap<void (*)(A1, A2, A3, A4)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3,
								check<A3>(L, 3))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4,
								check<A4>(L, 4))) {
					return 0;
				}
				((void (*)(A1, A2, A3, A4))lua_touserdata(L,
						lua_upvalueindex(1)))(get<A1>(L, 1), get<A2>(L, 2),
						get<A3>(L, 3), get<A4>(L, 4));
				return 0;
			}
		};

		template<typename R, typename A1, typename A2, typename A3, typename A4>
		struct FuncWrap<R (*)(A1, A2, A3, A4)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3,
								check<A3>(L, 3))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4,
								check<A4>(L, 4))) {
					return 0;
				}
				push<R>(L,
						((R (*)(A1, A2, A3, A4))lua_touserdata(L,
								lua_upvalueindex(1)))(get<A1>(L, 1),
								get<A2>(L, 2), get<A3>(L, 3), get<A4>(L, 4)));
				return 1;
			}
		};

		template<typename A1, typename A2, typename A3, typename A4, typename A5>
		struct FuncWrap<void (*)(A1, A2, A3, A4, A5)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3,
								check<A3>(L, 3))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4,
								check<A4>(L, 4))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5,
								check<A5>(L, 5))) {
					return 0;
				}
				((void (*)(A1, A2, A3, A4, A5))lua_touserdata(L,
						lua_upvalueindex(1)))(get<A1>(L, 1), get<A2>(L, 2),
						get<A3>(L, 3), get<A4>(L, 4), get<A5>(L, 5));
				return 0;
			}
		};

		template<typename R, typename A1, typename A2, typename A3, typename A4,
				typename A5>
		struct FuncWrap<R (*)(A1, A2, A3, A4, A5)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3,
								check<A3>(L, 3))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4,
								check<A4>(L, 4))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5,
								check<A5>(L, 5))) {
					return 0;
				}
				push<R>(L,
						((R (*)(A1, A2, A3, A4, A5))lua_touserdata(L,
								lua_upvalueindex(1)))(get<A1>(L, 1),
								get<A2>(L, 2), get<A3>(L, 3), get<A4>(L, 4),
								get<A5>(L, 5)));
				return 1;
			}
		};

		template<typename A1, typename A2, typename A3, typename A4,
				typename A5, typename A6>
		struct FuncWrap<void (*)(A1, A2, A3, A4, A5, A6)> {
			static int cppfunction(lua_State* L) {
				if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1,
						check<A1>(L, 1))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2,
								check<A2>(L, 2))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3,
								check<A3>(L, 3))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4,
								check<A4>(L, 4))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5,
								check<A5>(L, 5))
						|| !argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6,
								check<A6>(L, 6))) {
					return 0;
				}
				((void (*)(A1, A2, A3, A4, A5, A6))lua_touserdata(L,
						lua_upvalueindex(1)))(get<A1>(L, 1), get<A2>(L, 2),
						get<A3>(L, 3), get<A4>(L, 4), get<A5>(L, 5),
						get<A6>(L, 6));
				return 0;
			}
		};

#ifdef LUAWRAP_LONG_FUNCTIONS
	template<typename R, typename A1,typename A2,typename A3,typename A4,typename A5,typename A6>
	struct FuncWrap<R (*)(A1,A2,A3,A4,A5,A6)> {
		static int cppfunction(lua_State* L) {
			if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1, check<A1>(L, 1))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2, check<A2>(L, 2))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3, check<A3>(L, 3))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4, check<A4>(L, 4))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5, check<A5>(L, 5))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6, check<A6>(L, 6))) {return 0;}
			push<R>(L, ((R (*)(A1,A2,A3,A4,A5,A6))lua_touserdata(L, lua_upvalueindex(1)))(get<A1>(L, 1),get<A2>(L, 2),get<A3>(L, 3),get<A4>(L, 4),get<A5>(L, 5),get<A6>(L, 6)));
			return 1;
		}
	};

	template<typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7>
	struct FuncWrap<void (*)(A1,A2,A3,A4,A5,A6,A7)> {
		static int cppfunction(lua_State* L) {
			if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1, check<A1>(L, 1))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2, check<A2>(L, 2))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3, check<A3>(L, 3))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4, check<A4>(L, 4))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5, check<A5>(L, 5))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6, check<A6>(L, 6))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 7, check<A7>(L, 7))) {return 0;}
			((void (*)(A1,A2,A3,A4,A5,A6,A7))lua_touserdata(L, lua_upvalueindex(1)))(get<A1>(L, 1),get<A2>(L, 2),get<A3>(L, 3),get<A4>(L, 4),get<A5>(L, 5),get<A6>(L, 6),get<A7>(L, 7));
			return 0;
		}
	};

	template<typename R, typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7>
	struct FuncWrap<R (*)(A1,A2,A3,A4,A5,A6,A7)> {
		static int cppfunction(lua_State* L) {
			if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1, check<A1>(L, 1))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2, check<A2>(L, 2))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3, check<A3>(L, 3))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4, check<A4>(L, 4))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5, check<A5>(L, 5))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6, check<A6>(L, 6))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 7, check<A7>(L, 7))) {return 0;}
			push<R>(L, ((R (*)(A1,A2,A3,A4,A5,A6,A7))lua_touserdata(L, lua_upvalueindex(1)))(get<A1>(L, 1),get<A2>(L, 2),get<A3>(L, 3),get<A4>(L, 4),get<A5>(L, 5),get<A6>(L, 6),get<A7>(L, 7)));
			return 1;
		}
	};

	template<typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8>
	struct FuncWrap<void (*)(A1,A2,A3,A4,A5,A6,A7,A8)> {
		static int cppfunction(lua_State* L) {
			if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1, check<A1>(L, 1))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2, check<A2>(L, 2))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3, check<A3>(L, 3))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4, check<A4>(L, 4))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5, check<A5>(L, 5))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6, check<A6>(L, 6))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 7, check<A7>(L, 7))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 8, check<A8>(L, 8))) {return 0;}
			((void (*)(A1,A2,A3,A4,A5,A6,A7,A8))lua_touserdata(L, lua_upvalueindex(1)))(get<A1>(L, 1),get<A2>(L, 2),get<A3>(L, 3),get<A4>(L, 4),get<A5>(L, 5),get<A6>(L, 6),get<A7>(L, 7),get<A8>(L, 8));
			return 0;
		}
	};

	template<typename R, typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8>
	struct FuncWrap<R (*)(A1,A2,A3,A4,A5,A6,A7,A8)> {
		static int cppfunction(lua_State* L) {
			if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1, check<A1>(L, 1))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2, check<A2>(L, 2))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3, check<A3>(L, 3))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4, check<A4>(L, 4))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5, check<A5>(L, 5))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6, check<A6>(L, 6))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 7, check<A7>(L, 7))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 8, check<A8>(L, 8))) {return 0;}
			push<R>(L, ((R (*)(A1,A2,A3,A4,A5,A6,A7,A8))lua_touserdata(L, lua_upvalueindex(1)))(get<A1>(L, 1),get<A2>(L, 2),get<A3>(L, 3),get<A4>(L, 4),get<A5>(L, 5),get<A6>(L, 6),get<A7>(L, 7),get<A8>(L, 8)));
			return 1;
		}
	};

	template<typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8,typename A9>
	struct FuncWrap<void (*)(A1,A2,A3,A4,A5,A6,A7,A8,A9)> {
		static int cppfunction(lua_State* L) {
			if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1, check<A1>(L, 1))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2, check<A2>(L, 2))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3, check<A3>(L, 3))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4, check<A4>(L, 4))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5, check<A5>(L, 5))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6, check<A6>(L, 6))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 7, check<A7>(L, 7))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 8, check<A8>(L, 8))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 9, check<A9>(L, 9))) {return 0;}
			((void (*)(A1,A2,A3,A4,A5,A6,A7,A8,A9))lua_touserdata(L, lua_upvalueindex(1)))(get<A1>(L, 1),get<A2>(L, 2),get<A3>(L, 3),get<A4>(L, 4),get<A5>(L, 5),get<A6>(L, 6),get<A7>(L, 7),get<A8>(L, 8),get<A9>(L, 9));
			return 0;
		}
	};

	template<typename R, typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8,typename A9>
	struct FuncWrap<R (*)(A1,A2,A3,A4,A5,A6,A7,A8,A9)> {
		static int cppfunction(lua_State* L) {
			if (!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 1, check<A1>(L, 1))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 2, check<A2>(L, 2))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 3, check<A3>(L, 3))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 4, check<A4>(L, 4))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 5, check<A5>(L, 5))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 6, check<A6>(L, 6))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 7, check<A7>(L, 7))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 8, check<A8>(L, 8))||!argcheck(L, lua_tostring(L, lua_upvalueindex(2)), 9, check<A9>(L, 9))) {return 0;}
			push<R>(L, ((R (*)(A1,A2,A3,A4,A5,A6,A7,A8,A9))lua_touserdata(L, lua_upvalueindex(1)))(get<A1>(L, 1),get<A2>(L, 2),get<A3>(L, 3),get<A4>(L, 4),get<A5>(L, 5),get<A6>(L, 6),get<A7>(L, 7),get<A8>(L, 8),get<A9>(L, 9)));
			return 1;
		}
	};
#endif

	/******************************************************************************
	 * END AUTOGENERATED CODE -- Here be DRAGONS. Use generate-functions.py       *
	 ******************************************************************************/
	}
}

namespace luawrap {

	inline void push_function(lua_State* L, const char* fname,
			lua_CFunction func) {
		lua_pushcfunction(L, func);
	}

	template<typename Function>
	inline void push_function(lua_State* L, const char* fname, Function func) {
		lua_pushlightuserdata(L, (void*)func);
		if (fname) {
			lua_pushstring(L, fname);
		} else {
			lua_pushfstring(L, "[function %s at 0x%p]", typeid(Function).name(),
					(void*)func);
		}
		lua_pushcclosure(L, _private::FuncWrap<Function>::cppfunction, 2);
	}
	template<typename Function>
	inline void push_function(lua_State* L, Function func) {
		push_function(L, NULL, func);
	}

	template<typename Function>
	inline LuaValue function(lua_State* L, const char* name, Function func) {
		push_function(L, name, func);
		LuaValue val(L, -1);
		lua_pop(L, 1);
		return val;
	}

	template<typename Function>
	inline LuaValue function(lua_State* L, Function func) {
		return function(L, NULL, func);
	}
}

template<typename Function>
inline void LuaField::bind_function(const Function& function) const {
	char buffer[32]; /* int to string buffer */
	const char* key; /* points to index (either string or converted number) */
	if (_index_type == 1) {
		key = _index.string;
	} else {
		sprintf(buffer, "%d", _index.integer);
		key = buffer;
	}
	luawrap::push_function(L, key, function);
	pop();
}

#endif /* LUAWRAP_FUNCTIONS_H_ */
