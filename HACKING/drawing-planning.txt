-- Makes sense for having a higher level structure representing the drawing of players/enemies
-- Also, need a heirarchy of drawing effects
-- Need very generic input
	Direction, animation step ... <- Roll all into DrawOptions()!


Use case:
enemy

(... Theres some recursive data structure fun going on here, if we have no problem allocating small string/vectors, Allocating the small objects needed should be a non-issue)

DrawableBase <- Image 
	 <- Animation <- vector of Drawable ?
		<- takes frame = (X)
		<- How to handle advanced animation use cases ?
			<- for example, 'destroy once animation finished'
			<- Return value for draw -- a bit inadequate
				<- animation duration ? but what would a lua closure do. <- scratch that, just bind a value that represents animation duration
				Duration = 0 == nonanimated
				in lua <- Drawable(func, duration)
	 <- LuaDrawable
		<- takes object data and method table
		<- object has .size
		<- methods have .draw
		<- could almooost be a closure, if not for .size requirement
			<- screw the size requirement! origins do the trick
	 <- Shape

Drawable = wrapper of smartptr

How to wrap Drawable to lua ?
	Image specific methods should be available
	Can use SLB to bind methods to a metatable 'manually'
	Lua method is thus -> 'push metatable'?
		-This should be cached per-class in a LuaValue(?)
		-Ideally it would be cached per-lua-state
		-Use a static variable as the key for registry??
			-Class name is convenient ... for now
How to determine if enemy should be drawn ? (using radius should be OK)


How to support multiple layers at different depths ?
<- Have a DrawClosure
	<- Union of:
		obj_id id
		draw function
		Closure
	if (id == 0):
		<- object removed
		<- closure deleted
20 bytes / shadow (example):
	RAM is cheap ... thankfully


Example usage:

static bool draw_shadow(GameInst* obj) {
	return true;
}
class MyGameInst {
	...
}
