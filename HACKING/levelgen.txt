Time to write up a powerful specification and implement it...
This should get its own sub-project. It depends on YAML & Lua, but not much else. I'm sure other projects would want to use a free level generator (make sure its suitable for roguelikes -- easy). Would be able to prototype it.

REQUIREMENTS

We need a flexible model that allows for high-level random choices along with low level

--> Need an abstract model of a level, several layers
	-> low: resolved tiles with specific subtile
	-> middle: semi-resolved tiles with extra processing information
	-> high: a tree of marked-up features
		-> Each node contains:
			A back-pointer to the parent node for traversal
			A type:
			-> Shapes: oval, rectangle etc [Don't implement fancy shapes like N-sided polygons yet, but leave room for their implementation]
			-> Pre-resolved layouts
			A list of subnodes
			A feature list:
			-> 
		-> Room strategy for each node, lua function
			-> Given: Tree, Node, Rectangular area
			-> by default this is random-fit, can also be binary-space-partitioning
			-> Returns: a rectangular area for each sub-node
		-> Tunnel strategy for each node, lua function
			-> by default this is random-fit, can also be binary-space-partitioning
			-> Handles a rectangular area to each node
	-> higher still: A level generator is a lua function that takes a table of data (exported from YAML) and returns a high-level level layout

DATA MODEL

-- Highlevel --
Tree:
	Node list <-- all nodes are allocated to this list

Node:
	Shape 
	enum shape

Tree is immutable once created (for simplicity)
		

Node lua impl:
	shared pointer to tree
	node index

-- Middlelevel --

Level:
	Region list
Region:
	
Level lua impl:
	Opaque smart-pointer with room generation functions
	Rectangular clipping to ensure no spill-over ?

-- Lowlevel --
Tiles -- resolved to a tile ID and subindex
Objects -- created objects that simply need to be init'd ?
	--> Make sure to provide mechanism of creating objects without placing them immediately (although immediate placement should be default)

ALGORITHMS

place random shapes -- takes level, clipping area, shape size
place fixed layout -- 
	this should be able to recursively call the level generator ?


YAML mockup:
	-- High-level dungeon layouts need to be similarly connected
	-- All levels that WILL exist must be decided up-front? This could be a pain for 'infinite' worlds
		-- Eg the overworld must know that a level has a two-way portal to it so that it can generate one -- Make these one-way portals
			-- This does bring up the question -- how do you decide where such a portal will be in _both_ levels ?
				-- This requires some way of marking regions so that they can be connected in the high-level layout markup
				-- Ideally we want to know what levels exist before generating the current level
				-- If eg a temple exists, we want an inline temple level with a portal
	-- How to implement levels that are created with some % chance? Lua function that returns the level layout?
		-- Eg I want to generate a temple in this dungeon branch only if a certain feature exists on overworld
		-- Ability to query what currently exists, with undecided values returned. Can force them to be decided.
	-- Seems the tree generator function should just decide what we are connected to ?
		-- There is some question of how to connect siblings ?
			2way portals must come in pairs
			leave it as a lua function that resolves to the correct level, forcing it to exist
				This is most flexible, functional laziness is good here
				levels are thus primarily a bunch of lua functions
				picks not just the level to connect, but specific location
				can query the whole layout tree (simplify this somehow! eg portal markers. power is good but convenience first)
	-- OK this is all good and well, but how do you give dungeons names ? How do you display (and decide) dungeon depth ?
		-- Tricky subject. One layout can be used in multiple, named, dungeons
		-- When layout formats get too complex, use code!

branches -> levels (heirarchical) -> level features (heirarchical)
levels can be part of a branch, or have a simple name for eg temporary or common portals (A bazaar)
branches are just a list that link a series of floors
	-- should parts of a level belong to branches ?? (eg enter a room in overworld, YOU HAVE ENTERED DUNGEON1 pops up)
		-- This can get incredibly complex ... OTOH if its not done up-front, it'll never be done
			-- Need some way of querying whether we are within a specific subregion
			-- Can keep track of perimeter ? a bitmask is most specific here. Do we keep bitmasks for all regions regardless?

function generate_overworld()
	local dngn1 = levelgen.branch_create("D1")
	local dngn2 = levelgen.branch_create("D2") -- branches should start as unknown ? allow for this possibility
	local overworld = levels.Overworld.create() -- Common pattern could be returning essential layout, and then adding conditional features
	overworld:add()
end

levels:
# Usually more akin to level sublayouts
	- name: Overworld
	  template_func: overworld
	  size: [256, 256]
	  sublayouts: [OverworldFountain, Dungeon]

	- name: OverworldFountain
	  template_func: fountain
 	  size: 

	- name: Dungeon
	  template_func: ...
          ... layout parameters ...
		..
